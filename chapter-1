[1.2]  (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

[1.3] 
(defun square (a) (* a a))

(defun sum-of-squre-of-two-larger-numbers (a b c) (
cond ((and (< a b) (< a c)) (+ b c))
((and (< b c) (< b a)) (+ a c))
((and (< c b) (< c a)) (+ b a))
(else (+ a b))))

(defun sum-of-squares-of-two-larger-numbers-of-three-numbers (a b c) (sum-of-squre-of-two-larger-numbers (square a) (square b) (square c)))

sample usage:

(sum-of-squares-of-two-larger-numbers-of-three-numbers 2 4 5) = 41

[1.4] 
1st case:
if b > 0, operator = + 
else operator = - (2 possible cases: b <= 0)

sample case:
i.  a = 2, b = -2
ans = 2 - (-2) = 4

ii. a = 2, b = 2
ans = 2 + 2 = 4

iii. a = 2, b = 0
ans = 2 - 0 = 2

Hence, we can agree that the procedure sums of the value a with the absolute value of b. 

[1.5]
(define (p) (p))
(define (test x y)
(if (= x 0) 0
y))

(test 0 (p))

applicative-order-execution: 

applicative order execution only evaluates a procedure when it is the first in the execution bracket.

- (test 0 (p))
- (if (= 0 0)
0
(p))) = 0

NOTE: No need to execute p procedure

normal-order-execution:

normal order execution evaluates all procedures in a procedure until you are left with primitive operands and operators. 

- (test 0 (p))
- (if (= 0 0)
0
(p))
)

- (if (= 0 0)
0
NIL)
) = 0

Observation: The applicative order used 2 steps in executing the procedure while the normal order used 3 steps in executing the same procedure. 

[1.6]
It increases the number of operations for the overall procedure since the new-ifprocedure has to be decomposed to primitive operands and operators.

